/*

	SolidQ Adaptive BI Framework 3.0

	Compilation:
		Date			: {{ ABI.Compiler.CompilationDateTime }}

	===== TEMPLATE 

	Template:
		Pattern			: Full 
		Flavor			: Single
		Source			: View
		Type			: SQL
		Authors			: dmauri
		Revision		: 1
		Created			: 2015-08-26, dmauri
		Updated			: 2015-08-26, dmauri
	
	Required:
		MetadataVersion	: 1

	======

*/

{% include "extract/full" %}

/*
	===== UPDATE CONFIGURATION DATABASE
*/
USE [{{ Connections.Configuration.Database }}]
GO

--
-- Upsert "Extract Phase" Configuration
--
MERGE INTO
	[cfg].[extract_phase] t 
USING
	(VALUES('{{ Object.SourceObject.FullName }}', 'Y')) s(source_object_name, active_for_load)
ON
	t.source_object_name = s.source_object_name
WHEN NOT MATCHED THEN
	INSERT VALUES (s.source_object_name, s.active_for_load)
WHEN MATCHED THEN
	UPDATE SET t.active_for_load = t.active_for_load
;


/*
	===== UPDATE METADATA DATABASE
*/
USE [{{ Connections.Metadata.Database }}]
GO

--
-- Upsert "Extract Phase Info" Metadata
--
MERGE INTO
	[md].[extract_phase_info] t 
USING
	(VALUES('{{ Object.SourceObject.FullName }}', '{{ Object.DestinationTable.FullName }}', 'FS', 'VIW', '{{ Object.PrimaryKeyColumns | Join ',' }}', {{ Object.DestinationTable.CreatePrimaryKey }})) s(source_object_name, destination_table_name, etl_pattern_id, source_type_id, primary_key_columns, create_primary_key_in_destination)
ON
	t.source_object_name = s.source_object_name
WHEN NOT MATCHED THEN
	INSERT (source_object_name, destination_table_name, etl_pattern_id, source_type_id, primary_key_columns, create_primary_key_in_destination) 
	VALUES (s.source_object_name, s.destination_table_name, s.etl_pattern_id, s.source_type_id, s.primary_key_columns, s.create_primary_key_in_destination)
WHEN MATCHED THEN
	UPDATE SET 
		t.destination_table_name = s.destination_table_name,
		t.etl_pattern_id = s.etl_pattern_id,
		t.source_type_id = s.source_type_id,
		t.primary_key_columns = s.primary_key_columns,
		t.create_primary_key_in_destination = s.create_primary_key_in_destination
;

--
-- Upsert "Connections" Metadata
--
MERGE INTO
	[md].[etl_connections] t 
USING
	(VALUES
		{% for Helper in Connections.Helpers -%}
		('{{ Helper.Name }}', 'HLP', '{{ Helper.ConnectionString }}', '', '') {% if forloop.last == false %} , {% endif %}
		{% endfor -%}
	) s([name], [type], [connection_string], [provider], [description])
ON
	t.[name] = s.[name]
WHEN NOT MATCHED THEN
	INSERT ([name], [type], [connection_string], [provider], [description])
	VALUES (s.[name], s.[type], s.[connection_string], s.[provider], s.[description])
WHEN MATCHED THEN
	UPDATE SET 
		t.[name] = s.[name], 
		t.[type] = s.[type], 
		t.[connection_string] = s.[connection_string], 
		t.[provider] = s.[provider], 
		t.[description] = s.[description]
;

--
-- Refresh "Extract Phase Info Connections" Relationships
--
DELETE FROM [md].[extract_phase_info_connections] WHERE [source_object_name] = '{{ Object.SourceObject.FullName }}';

INSERT INTO 
	[md].[extract_phase_info_connections] (source_object_name, etl_connection_id, extract_tag)
SELECT 
	'{{ Object.SourceObject.FullName }}', etl_connection_id, 0 
FROM 
	[md].[etl_connections] 
WHERE 
	name IN 
	( 
	{% for Helper in Connections.Helpers -%}
	'{{ Helper.Name }}' {% if forloop.last == false %} , {% endif %}
	{% endfor -%}
	);
